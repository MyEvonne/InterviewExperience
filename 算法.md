# 算法篇
## 1.判断平衡二叉树
>平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

``` swift
  class Solution {
    func isBalanced(_ root: TreeNode?) -> Bool {
      guard let rootNode = root else { return true }
      if rootNode.left == nil, rootNode.right == nil {
        return true
      } else {
        let leftDepth: Int = maxDepth(rootNode.left)
        let rightDepth: Int = maxDepth(rootNode.right)
        let differentDepth: Int = abs(leftDepth - rightDepth)
        if differentDepth > 1 {
          return false
        } else {
          return isBalanced(rootNode.left) && isBalanced(rootNode.right)
        }
      }
    }
    //这里可以把每个节点的深度都存下来，计算效率会更高一些。
    func maxDepth(_ root: TreeNode?) -> Int {
      guard let rootNode = root else { return 0 }
      return max(maxDepth(rootNode.left), maxDepth(rootNode.right)) + 1
    }
  }
```

## 2.LFU
>最不经常使用（LFU）缓存算法

实现 `LFUCache` 类：

* `LFUCache(int capacity)`- 用数据结构的容量 `capacity` 初始化对象
* `int get(int key)`- 如果键存在于缓存中，则获取键的值，否则返回 -1。
* `void put(int key, int value)`- 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除**最久未使用**的键。  

**注意**「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

进阶：你是否可以在**O(1)**时间复杂度内执行两项操作？


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lfu-cache
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这个题目标准的解答方法应该是用双链表来写，我只是想用这个方式写一下。
```swift
class LFUCache {
  var capacity: Int = 0
  var allNodes: [Int: LFUListNode] = [:]
  var freNodes: [Int: [LFUListNode]] = [:]
  var minFrequency: Int = 1

  init(_ capacity: Int) {
    self.capacity = capacity
  }

  func get(_ key: Int) -> Int {
    guard let node = allNodes[key] else { return -1 }
    updateFrequency(node: node)
    return node.value
  }

  func put(_ key: Int, _ value: Int) {
    guard capacity > 0 else {
      return
    }
    if let node = allNodes[key] {
      node.value = value
      updateFrequency(node: node)
    } else {
      let node: LFUListNode = LFUListNode(key: key, value: value)
      if allNodes.count < capacity {
        allNodes[key] = node
      } else {
        guard let popoutNode = popoutNode() else { return }
        allNodes.removeValue(forKey: popoutNode.key)
        allNodes[key] = node
      }
      updateFrequency(node: node)
      minFrequency = min(minFrequency, node.frequency)
    }
  }

  func updateFrequency(node: LFUListNode) {
    // Remove from old array first.
    if node.frequency > 0, var nodes = freNodes[node.frequency] {
      for index in 0..<nodes.count {
        if nodes[index].key == node.key {
          nodes.remove(at: index)
          break
        }
      }
      if nodes.count == 0 {
        freNodes.removeValue(forKey: node.frequency)
      } else {
        freNodes[node.frequency] = nodes
      }
    }
    node.frequency += 1
    if var nodes = freNodes[node.frequency] {
      nodes.insert(node, at: 0)
      freNodes[node.frequency] = nodes
    } else {
      freNodes[node.frequency] = [node]
    }
    if freNodes.keys.count > 0 {
      minFrequency = freNodes.keys.first!
      for frequency in freNodes.keys {
        minFrequency = min(minFrequency, frequency)
      }
    } else {
      minFrequency = 1
    }
  }

  func popoutNode() -> LFUListNode? {
    guard var nodes = freNodes[minFrequency] else { return nil }
    let lastNode: LFUListNode = nodes.removeLast()
    if nodes.count == 0 {
      freNodes.removeValue(forKey: minFrequency)
    } else {
      freNodes[minFrequency] = nodes
    }
    return lastNode
  }

  class LFUListNode: CustomStringConvertible {
    var key: Int
    var value: Int
    var frequency: Int = 0

    init(key: Int, value: Int) {
      self.key = key
      self.value = value
    }

    var description: String {
      return "key: " + String(key) + " value: " + String(value) + " frequency: " + String(frequency)
    }
  }
}
```
