# 算法篇
## 1.判断平衡二叉树
>平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

``` swift
  class Solution {
    func isBalanced(_ root: TreeNode?) -> Bool {
      guard let rootNode = root else { return true }
      if rootNode.left == nil, rootNode.right == nil {
        return true
      } else {
        let leftDepth: Int = maxDepth(rootNode.left)
        let rightDepth: Int = maxDepth(rootNode.right)
        let differentDepth: Int = abs(leftDepth - rightDepth)
        if differentDepth > 1 {
          return false
        } else {
          return isBalanced(rootNode.left) && isBalanced(rootNode.right)
        }
      }
    }
    //这里可以把每个节点的深度都存下来，计算效率会更高一些。
    func maxDepth(_ root: TreeNode?) -> Int {
      guard let rootNode = root else { return 0 }
      return max(maxDepth(rootNode.left), maxDepth(rootNode.right)) + 1
    }
  }
```

## 2.LFU
>最不经常使用（LFU）缓存算法

实现 `LFUCache` 类：

* `LFUCache(int capacity)`- 用数据结构的容量 `capacity` 初始化对象
* `int get(int key)`- 如果键存在于缓存中，则获取键的值，否则返回 -1。
* `void put(int key, int value)`- 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除**最久未使用**的键。  

**注意**「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

进阶：你是否可以在**O(1)**时间复杂度内执行两项操作？


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lfu-cache
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这个题目标准的解答方法应该是用双链表来写，我只是想用这个方式写一下。
```swift
class LFUCache {
  var capacity: Int = 0
  var allNodes: [Int: LFUListNode] = [:]
  var freNodes: [Int: [LFUListNode]] = [:]
  var minFrequency: Int = 1

  init(_ capacity: Int) {
    self.capacity = capacity
  }

  func get(_ key: Int) -> Int {
    guard let node = allNodes[key] else { return -1 }
    updateFrequency(node: node)
    return node.value
  }

  func put(_ key: Int, _ value: Int) {
    guard capacity > 0 else {
      return
    }
    if let node = allNodes[key] {
      node.value = value
      updateFrequency(node: node)
    } else {
      let node: LFUListNode = LFUListNode(key: key, value: value)
      if allNodes.count < capacity {
        allNodes[key] = node
      } else {
        guard let popoutNode = popoutNode() else { return }
        allNodes.removeValue(forKey: popoutNode.key)
        allNodes[key] = node
      }
      updateFrequency(node: node)
      minFrequency = min(minFrequency, node.frequency)
    }
  }

  func updateFrequency(node: LFUListNode) {
    // Remove from old array first.
    if node.frequency > 0, var nodes = freNodes[node.frequency] {
      for index in 0..<nodes.count {
        if nodes[index].key == node.key {
          nodes.remove(at: index)
          break
        }
      }
      if nodes.count == 0 {
        freNodes.removeValue(forKey: node.frequency)
      } else {
        freNodes[node.frequency] = nodes
      }
    }
    node.frequency += 1
    if var nodes = freNodes[node.frequency] {
      nodes.insert(node, at: 0)
      freNodes[node.frequency] = nodes
    } else {
      freNodes[node.frequency] = [node]
    }
    if freNodes.keys.count > 0 {
      minFrequency = freNodes.keys.first!
      for frequency in freNodes.keys {
        minFrequency = min(minFrequency, frequency)
      }
    } else {
      minFrequency = 1
    }
  }

  func popoutNode() -> LFUListNode? {
    guard var nodes = freNodes[minFrequency] else { return nil }
    let lastNode: LFUListNode = nodes.removeLast()
    if nodes.count == 0 {
      freNodes.removeValue(forKey: minFrequency)
    } else {
      freNodes[minFrequency] = nodes
    }
    return lastNode
  }

  class LFUListNode: CustomStringConvertible {
    var key: Int
    var value: Int
    var frequency: Int = 0

    init(key: Int, value: Int) {
      self.key = key
      self.value = value
    }

    var description: String {
      return "key: " + String(key) + " value: " + String(value) + " frequency: " + String(frequency)
    }
  }
}
```

## 3.计算时间复杂度以及空间复杂度
>**算法的时间复杂度** 是指算法对时间的需求。一个算法的运行时间通常与所解决问题的规模大小有关。  
例如，在排序问题中，排序的元素个数n就是问题规模，排序算法中基本操作语句的重复执行次数随着问题规模n的增大而增加。  
一般情况下，算法中基本操作重复执行的次数T(n)是问题规模n的某个函数f(n)。因此，算法的时间效率可记为：**T(n)= O(f(n))
表示随问题规模n的增大，算法的执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。**表达式中O的含义是指T(n)的数量级。一般情况下，当Tn)为多项式时，可只取最高次幂项，且系数也可省略。例如：T(n)=3n²+n-9 则T(n)=O(n²)。  
一般地，算法所消耗的时间是每条语句的执行时间之和。每条语句的执行时间是其执行次数(频度)与该语句执行一次所需时间的乘积。在计算机中，程序语句的执行时间与计算机的性能有关，因此在分析算法的执行效率时，假设语句执行时间与机器无关，只考虑所有语句的执行次数。  
算法中的基本操作可以理解为算法程序中最深层循环内的语句中的基本操作，它的执行次数(频度)与包含它的语句的执行次数相同。

>**空间复杂度**是指算法执行过程对计算机存储空间的要求，称为算法的空间复杂度。类似于时间复杂度，记为 **S(n)= O(f(n))** 其中n是问题的规模。  
通常，执行一个算法程序除了需要存储空间存放本身所用的指令、常数、变量和输出数据外，还需要一些辅助空间用于对数据进行处理及存储处理过程中的中间信息。若输入数据所占的空间只取决于问题本身而与算法无关，则只需要分析除了输入和程序之外的辅助空间需求。算法的空间复杂度通常就是指这种辅助空间需求的大小。

T(n)与n的最高阶数关系	| 名称 | 描述
:--:|:--:|:--
T(n)=O(1) |	常数阶  恒久不变(constant) | **这是最好的算法** 不管有多少数据算法总是需要相同的时间量。示例：用索引查找数组的元素。
T(n)=O(log n) |	对数阶 (logarithmic) | **非常好** 这些算法在每次迭代中将数据量减半。如果你有100个项目，需要大约7个步骤才能找到答案。有1000项, 它需要10个步骤，1000000项只采取20个步骤。即使对于大量的数据，这也是非常快的。示例：二进制搜索。
T(n)=O(n) |	线性阶 | **良好性能** 如果你有100项, 这是100单位的工作，将项目的数量加倍使得算法花费了两倍长（200个工作单位）。例子：顺序搜索。
T(n)=O(n log n) |	线性化(linearithmic) | **体面的表现** 这比线性略差，但也不坏。例子：最快的通用排序算法。
T(n)=O(n²) |	平方(quadratic) | **有点慢** 如果你有100个项目，这就等于100 ^ 2＝10000个单位的工作。将项目数加倍使其慢四倍（因为2的平方等于4）。示例：使用嵌套循环的算法，如插入排序、冒泡排序。
T(n)=O(n³) |	立方(cubic) | **性能不佳** 如果你有100项, 这做 100 ^ 3 = 100万单位的工作。加倍输入大小使其慢了八倍。例子：矩阵乘法。
T(n)=O(2^n ) |	指数级(exponential) | **性能非常差** 你想避免这些算法，但有时你别无选择。只需在输入中添加一位即可使运行时间加倍。示例: 旅行推销员问题。
T(n)=O(n!) |	阶乘(factorial) | **难以忍受的缓慢** 做任何事情都需要一百万年的时间。

https://juejin.im/entry/6844903614310268942

### 时间复杂度的计算
1. 找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

2. 计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

3. 用大Ο记号表示算法的时间性能。将基本语句执行次数的数量级放入大Ο记号中。如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。

4. 对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间。对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"。对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间。对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"。乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1T2=O(f(n)g(n))。

对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度。另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数。

作者：一个人在路上走下去
链接：https://www.jianshu.com/p/c8c58a23ad5a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 4. 一个操作如果耗时5秒后，返回nil，否则返回一个字符串，请设计。
此题使用 oc dispatch_semaphore_t 来解决，模拟一个时间不固定的异步任务；callback 是根据题目要求，5s 为分水岭返回不同的结果。

```objc

- (void)asynTask:(NSUInteger)time callback:(void (^)(NSString *))callback {
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    __block NSString *result = nil;

    // queue 不能为 dispatch_get_main_queue() 会阻塞
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), queue, ^{
        NSLog(@"异步任务结束");
        result = @"结束字符串";

        if (semaphore) {
            dispatch_semaphore_signal(semaphore);
        }
    });

    dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)));
    callback(result);

    semaphore = nil;
}

```

## 5. 有一个很大的整形数据，转成二进制求1的个数

## 6. 阶乘后的零
>给定一个整数 n，返回 n! 结果尾数中零的数量。

```swift
class Solution {
    func trailingZeroes(_ n: Int) -> Int {
        var zeroCount: Int = 0
        var divider: Int = 5
        while (n >= divider) {
            zeroCount += n / divider
            divider *= 5
        }
        return zeroCount
    }
}
```
时间复杂度: O(log n)
https://leetcode-cn.com/problems/factorial-trailing-zeroes/
